import {
  BrowseProposalNotificationData,
  BrowseProposalReminderData,
  NotificationData
} from '@booking-swap/shared';
import { NotificationService } from './NotificationService';
import { NotificationPreferencesService } from './NotificationPreferencesService';
import { SwapRepository } from '../../database/repositories/SwapRepository';
import { BookingService } from '../booking/BookingService';
import { SwapMatchingService } from '../swap/SwapMatchingService';
import { UserRepository } from '../../database/repositories/UserRepository';
import { logger } from '../../utils/logger';

export interface BrowseProposalReceivedData {
  proposalId: string;
  sourceSwapId: string;
  targetSwapId: string;
  proposerId: string;
  targetOwnerId: string;
  message?: string;
}

export interface BrowseProposalConfirmedData {
  proposalId: string;
  sourceSwapId: string;
  targetSwapId: string;
  proposerId: string;
  status: 'created' | 'pending_review';
}

export interface BrowseProposalStatusUpdateData {
  proposalId: string;
  sourceSwapId: string;
  targetSwapId: string;
  recipientUserId: string;
  status: 'accepted' | 'rejected' | 'expired' | 'withdrawn';
  updatedBy: string;
}

export class BrowseProposalNotificationService {
  private preferencesService: NotificationPreferencesService;

  constructor(
    private notificationService: NotificationService,
    private swapRepository: SwapRepository,
    private bookingService: BookingService,
    private userRepository: UserRepository,
    private swapMatchingService?: SwapMatchingService
  ) {
    this.preferencesService = new NotificationPreferencesService(userRepository);
  }

  /**
   * Send notification when a browse proposal is received
   * Requirements: 6.1, 6.2, 6.3
   */
  async sendBrowseProposalReceivedNotification(data: BrowseProposalReceivedData): Promise<void> {
    try {
      logger.info('Sending browse proposal received notification', {
        proposalId: data.proposalId,
        targetOwnerId: data.targetOwnerId,
        proposerId: data.proposerId
      });

      // Get enhanced notification data with swap details and compatibility
      const notificationData = await this.buildBrowseProposalNotificationData(data);

      // Check if user should receive notification based on preferences and compatibility
      const shouldSend = await this.preferencesService.shouldSendNotification(
        data.targetOwnerId,
        'browse_proposal_received',
        notificationData.compatibilityScore
      );

      if (!shouldSend) {
        logger.info('Skipping notification due to user preferences or low compatibility', {
          proposalId: data.proposalId,
          targetOwnerId: data.targetOwnerId,
          compatibilityScore: notificationData.compatibilityScore
        });
        return;
      }

      // Generate enhanced content with compatibility and comparison details
      const enhancedContent = await this.preferencesService.generateEnhancedNotificationContent(
        data.targetOwnerId,
        'browse_proposal_received',
        {
          subject: `New Swap Proposal from Browse Page - ${notificationData.sourceSwapDetails.title}`,
          content: 'Enhanced content will be generated by template service'
        },
        {
          compatibilityAnalysis: notificationData.compatibilityAnalysis,
          swapComparison: {
            source: notificationData.sourceSwapDetails,
            target: notificationData.targetSwapDetails
          }
        }
      );

      // Add enhanced content to notification data
      const enrichedNotificationData = {
        ...notificationData,
        enhancedContent,
        priority: enhancedContent.metadata.priority,
        richContent: enhancedContent.richContent
      };

      await this.notificationService.sendNotification(
        'browse_proposal_received',
        data.targetOwnerId,
        enrichedNotificationData
      );

      logger.info('Browse proposal received notification sent successfully', {
        proposalId: data.proposalId,
        targetOwnerId: data.targetOwnerId,
        priority: enhancedContent.metadata.priority,
        compatibilityScore: notificationData.compatibilityScore
      });
    } catch (error) {
      logger.error('Failed to send browse proposal received notification', {
        error: error instanceof Error ? error.message : 'Unknown error',
        proposalId: data.proposalId,
        targetOwnerId: data.targetOwnerId
      });
      throw error;
    }
  }

  /**
   * Send confirmation notification to proposer
   * Requirements: 6.1, 6.2
   */
  async sendBrowseProposalConfirmedNotification(data: BrowseProposalConfirmedData): Promise<void> {
    try {
      logger.info('Sending browse proposal confirmed notification', {
        proposalId: data.proposalId,
        proposerId: data.proposerId
      });

      // Get enhanced notification data
      const notificationData = await this.buildBrowseProposalNotificationData({
        proposalId: data.proposalId,
        sourceSwapId: data.sourceSwapId,
        targetSwapId: data.targetSwapId,
        proposerId: data.proposerId,
        targetOwnerId: '', // Not needed for confirmation
      });

      // Generate enhanced content for confirmation
      const enhancedContent = await this.preferencesService.generateEnhancedNotificationContent(
        data.proposerId,
        'browse_proposal_confirmed',
        {
          subject: `Proposal Submitted Successfully - ${notificationData.targetSwapDetails.title}`,
          content: 'Enhanced content will be generated by template service'
        },
        {
          compatibilityAnalysis: notificationData.compatibilityAnalysis,
          swapComparison: {
            source: notificationData.sourceSwapDetails,
            target: notificationData.targetSwapDetails
          }
        }
      );

      // Add confirmation-specific data
      const confirmationData = {
        ...notificationData,
        status: data.status,
        estimatedResponseTime: '2-3 business days',
        nextSteps: [
          'The swap owner will review your proposal',
          'You will receive a notification when they respond',
          'Check your proposals page for status updates'
        ],
        enhancedContent,
        priority: enhancedContent.metadata.priority,
        richContent: enhancedContent.richContent
      };

      await this.notificationService.sendNotification(
        'browse_proposal_confirmed',
        data.proposerId,
        confirmationData
      );

      logger.info('Browse proposal confirmed notification sent successfully', {
        proposalId: data.proposalId,
        proposerId: data.proposerId,
        priority: enhancedContent.metadata.priority
      });
    } catch (error) {
      logger.error('Failed to send browse proposal confirmed notification', {
        error: error instanceof Error ? error.message : 'Unknown error',
        proposalId: data.proposalId,
        proposerId: data.proposerId
      });
      throw error;
    }
  }

  /**
   * Send proposal status update notifications
   * Requirements: 6.2, 6.3
   */
  async sendBrowseProposalStatusUpdateNotification(data: BrowseProposalStatusUpdateData): Promise<void> {
    try {
      logger.info('Sending browse proposal status update notification', {
        proposalId: data.proposalId,
        recipientUserId: data.recipientUserId,
        status: data.status
      });

      // Get enhanced notification data
      const notificationData = await this.buildBrowseProposalNotificationData({
        proposalId: data.proposalId,
        sourceSwapId: data.sourceSwapId,
        targetSwapId: data.targetSwapId,
        proposerId: data.recipientUserId,
        targetOwnerId: data.updatedBy,
      });

      // Determine urgency based on status
      let urgency: 'low' | 'normal' | 'high' | 'urgent' = 'normal';
      if (data.status === 'accepted') urgency = 'high';
      if (data.status === 'rejected') urgency = 'low';

      // Generate enhanced content for status update
      const enhancedContent = await this.preferencesService.generateEnhancedNotificationContent(
        data.recipientUserId,
        'browse_proposal_status_update',
        {
          subject: `Proposal Update: ${notificationData.targetSwapDetails.title} - ${data.status}`,
          content: 'Enhanced content will be generated by template service'
        },
        {
          compatibilityAnalysis: notificationData.compatibilityAnalysis,
          swapComparison: {
            source: notificationData.sourceSwapDetails,
            target: notificationData.targetSwapDetails
          },
          urgency
        }
      );

      // Add status-specific data
      const statusUpdateData = {
        ...notificationData,
        status: data.status,
        updatedBy: data.updatedBy,
        statusMessage: this.getStatusMessage(data.status),
        actionRequired: data.status === 'accepted',
        enhancedContent,
        priority: enhancedContent.metadata.priority,
        richContent: enhancedContent.richContent,
        dashboardUrl: `${process.env.FRONTEND_URL}/dashboard/proposals`
      };

      await this.notificationService.sendNotification(
        'browse_proposal_status_update',
        data.recipientUserId,
        statusUpdateData
      );

      logger.info('Browse proposal status update notification sent successfully', {
        proposalId: data.proposalId,
        recipientUserId: data.recipientUserId,
        status: data.status,
        priority: enhancedContent.metadata.priority
      });
    } catch (error) {
      logger.error('Failed to send browse proposal status update notification', {
        error: error instanceof Error ? error.message : 'Unknown error',
        proposalId: data.proposalId,
        recipientUserId: data.recipientUserId,
        status: data.status
      });
      throw error;
    }
  }

  /**
   * Send reminder notifications for pending proposals
   * Requirements: 6.4, 6.5
   */
  async sendBrowseProposalReminderNotification(data: BrowseProposalReminderData): Promise<void> {
    try {
      logger.info('Sending browse proposal reminder notification', {
        proposalId: data.proposalId,
        reminderType: data.reminderType,
        hoursRemaining: data.hoursRemaining
      });

      // Determine recipient based on reminder type
      const proposal = await this.getProposalDetails(data.proposalId);
      if (!proposal) {
        throw new Error('Proposal not found for reminder notification');
      }

      const recipientUserId = proposal.targetOwnerId; // Reminder goes to the target swap owner

      // Check if user should receive reminder based on preferences
      const shouldSend = await this.preferencesService.shouldSendNotification(
        recipientUserId,
        'browse_proposal_reminder'
      );

      if (!shouldSend) {
        logger.info('Skipping reminder notification due to user preferences', {
          proposalId: data.proposalId,
          recipientUserId,
          reminderType: data.reminderType
        });
        return;
      }

      // Determine urgency based on hours remaining and reminder type
      let urgency: 'low' | 'normal' | 'high' | 'urgent' = 'normal';
      if (data.reminderType === 'final' || data.hoursRemaining <= 6) urgency = 'urgent';
      else if (data.hoursRemaining <= 24) urgency = 'high';

      // Generate enhanced content for reminder
      const enhancedContent = await this.preferencesService.generateEnhancedNotificationContent(
        recipientUserId,
        'browse_proposal_reminder',
        {
          subject: `⏰ Reminder: Swap Proposal Awaiting Your Review - ${data.targetSwapTitle}`,
          content: 'Enhanced content will be generated by template service'
        },
        {
          urgency,
          proposalId: data.proposalId
        }
      );
      
      const reminderData = {
        ...data,
        proposalId: data.proposalId,
        sourceSwapTitle: data.sourceSwapTitle,
        targetSwapTitle: data.targetSwapTitle,
        hoursRemaining: data.hoursRemaining,
        reminderType: data.reminderType,
        isUrgent: data.reminderType === 'final',
        enhancedContent,
        priority: enhancedContent.metadata.priority,
        richContent: enhancedContent.richContent,
        dashboardUrl: `${process.env.FRONTEND_URL}/dashboard/proposals/${data.proposalId}`,
        expirationWarning: data.hoursRemaining <= 24 ? 'This proposal will expire soon!' : undefined
      };

      await this.notificationService.sendNotification(
        'browse_proposal_reminder',
        recipientUserId,
        reminderData
      );

      logger.info('Browse proposal reminder notification sent successfully', {
        proposalId: data.proposalId,
        recipientUserId,
        reminderType: data.reminderType,
        priority: enhancedContent.metadata.priority,
        urgency
      });
    } catch (error) {
      logger.error('Failed to send browse proposal reminder notification', {
        error: error instanceof Error ? error.message : 'Unknown error',
        proposalId: data.proposalId,
        reminderType: data.reminderType
      });
      throw error;
    }
  }

  /**
   * Send multiple proposal notifications (when user has multiple proposals)
   * Requirements: 6.5
   */
  async sendMultipleProposalsNotification(targetOwnerId: string, proposalCount: number): Promise<void> {
    try {
      logger.info('Sending multiple proposals notification', {
        targetOwnerId,
        proposalCount
      });

      const notificationData = {
        proposalCount,
        dashboardUrl: `${process.env.FRONTEND_URL}/dashboard/proposals`,
        message: `You have ${proposalCount} pending swap proposals waiting for your review.`
      };

      await this.notificationService.sendNotification(
        'browse_proposal_received', // Reuse existing type with different data
        targetOwnerId,
        notificationData
      );

      logger.info('Multiple proposals notification sent successfully', {
        targetOwnerId,
        proposalCount
      });
    } catch (error) {
      logger.error('Failed to send multiple proposals notification', {
        error: error instanceof Error ? error.message : 'Unknown error',
        targetOwnerId,
        proposalCount
      });
      throw error;
    }
  }

  /**
   * Build comprehensive notification data with swap details and compatibility
   */
  private async buildBrowseProposalNotificationData(
    data: BrowseProposalReceivedData
  ): Promise<BrowseProposalNotificationData> {
    try {
      // Get swap details
      const [sourceSwap, targetSwap] = await Promise.all([
        this.swapRepository.findById(data.sourceSwapId),
        this.swapRepository.findById(data.targetSwapId)
      ]);

      if (!sourceSwap || !targetSwap) {
        throw new Error('Unable to retrieve swap details for notification');
      }

      // Get booking details
      const [sourceBooking, targetBooking] = await Promise.all([
        this.bookingService.getBookingById(sourceSwap.sourceBookingId),
        this.bookingService.getBookingById(targetSwap.sourceBookingId)
      ]);

      if (!sourceBooking || !targetBooking) {
        throw new Error('Unable to retrieve booking details for notification');
      }

      // Get compatibility analysis if service is available
      let compatibilityAnalysis;
      if (this.swapMatchingService) {
        try {
          const compatibility = await this.swapMatchingService.analyzeSwapCompatibility(
            data.sourceSwapId,
            data.targetSwapId
          );
          compatibilityAnalysis = {
            overallScore: compatibility.overallScore,
            locationScore: compatibility.factors.locationCompatibility.score,
            dateScore: compatibility.factors.dateCompatibility.score,
            valueScore: compatibility.factors.valueCompatibility.score,
            accommodationScore: compatibility.factors.accommodationCompatibility.score,
            guestScore: compatibility.factors.guestCompatibility.score
          };
        } catch (compatibilityError) {
          logger.warn('Failed to get compatibility analysis for notification', {
            error: compatibilityError instanceof Error ? compatibilityError.message : 'Unknown error',
            sourceSwapId: data.sourceSwapId,
            targetSwapId: data.targetSwapId
          });
        }
      }

      // Build comprehensive notification data
      const notificationData: BrowseProposalNotificationData = {
        proposalId: data.proposalId,
        sourceSwapId: data.sourceSwapId,
        targetSwapId: data.targetSwapId,
        proposerId: data.proposerId,
        targetOwnerId: data.targetOwnerId,
        message: data.message,
        compatibilityScore: compatibilityAnalysis?.overallScore,
        sourceSwapDetails: {
          title: sourceBooking.title,
          location: `${sourceBooking.location.city}, ${sourceBooking.location.country}`,
          dates: `${sourceBooking.dateRange.checkIn.toDateString()} - ${sourceBooking.dateRange.checkOut.toDateString()}`,
          value: sourceBooking.totalPrice || sourceBooking.swapValue || 0,
          accommodationType: sourceBooking.accommodationType || 'Unknown',
          guests: sourceBooking.guests || 1
        },
        targetSwapDetails: {
          title: targetBooking.title,
          location: `${targetBooking.location.city}, ${targetBooking.location.country}`,
          dates: `${targetBooking.dateRange.checkIn.toDateString()} - ${targetBooking.dateRange.checkOut.toDateString()}`,
          value: targetBooking.totalPrice || targetBooking.swapValue || 0,
          accommodationType: targetBooking.accommodationType || 'Unknown',
          guests: targetBooking.guests || 1
        },
        compatibilityAnalysis,
        dashboardUrl: `${process.env.FRONTEND_URL}/dashboard/proposals/${data.proposalId}`,
        proposalUrl: `${process.env.FRONTEND_URL}/proposals/${data.proposalId}`,
        browseUrl: `${process.env.FRONTEND_URL}/swaps/browse`
      };

      return notificationData;
    } catch (error) {
      logger.error('Failed to build browse proposal notification data', {
        error: error instanceof Error ? error.message : 'Unknown error',
        proposalId: data.proposalId
      });
      throw error;
    }
  }

  /**
   * Get proposal details for reminder notifications
   */
  private async getProposalDetails(proposalId: string): Promise<{ targetOwnerId: string } | null> {
    try {
      // This would typically query a proposals table or derive from swap data
      // For now, we'll implement a basic version that gets the info from swaps
      // In a real implementation, you'd have a proposals table with this data
      
      // TODO: Implement actual proposal lookup when proposals table is available
      logger.warn('getProposalDetails not fully implemented - using placeholder', { proposalId });
      
      return { targetOwnerId: 'placeholder-user-id' };
    } catch (error) {
      logger.error('Failed to get proposal details', {
        error: error instanceof Error ? error.message : 'Unknown error',
        proposalId
      });
      return null;
    }
  }

  /**
   * Get user-friendly status message
   */
  private getStatusMessage(status: string): string {
    const statusMessages: Record<string, string> = {
      accepted: 'Your proposal has been accepted! The swap process will begin shortly.',
      rejected: 'Your proposal was not selected. Your booking is now available for other proposals.',
      expired: 'Your proposal has expired. Your booking is now available for other proposals.',
      withdrawn: 'The proposal has been withdrawn by the proposer.'
    };

    return statusMessages[status] || `Proposal status updated to: ${status}`;
  }
}